#!/usr/bin/env ts-node

import { execSync } from "node:child_process";
import * as fs from "node:fs";
import * as path from "node:path";

const CSV_PATH = "data/paperforge.csv";
const PAPERFORGE_DIR = "data/paperforge";
const OUTPUT_DIR = "public/paperforge";
const INDEX_PATH = "lib/paperforge-catalog.ts";

interface CSVRow {
  id: string;
  name: string;
  postUrl: string;
  tokenPng: string;
}

function parseCSV(content: string): CSVRow[] {
  const lines = content.split("\n");

  return lines
    .slice(1)
    .map((line) => {
      if (!line.trim()) return null;
      const [id, name, postUrl, tokenPng] = line
        .split(",")
        .map((s) => s.trim());
      return { id, name, postUrl, tokenPng };
    })
    .filter(Boolean) as CSVRow[];
}

function extractTokenImage(
  zipPath: string,
  internalPath: string,
  outputPath: string
): boolean {
  try {
    // Create output directory
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Extract the file using unzip
    // -j = junk paths (don't create directory structure)
    // -o = overwrite without prompting
    // -q = quiet
    execSync(`unzip -joq "${zipPath}" "${internalPath}" -d "${outputDir}"`, {
      stdio: "pipe",
    });

    // The file will be extracted with its original name, so we need to rename it
    const extractedFilename = path.basename(internalPath);
    const extractedPath = path.join(outputDir, extractedFilename);

    if (fs.existsSync(extractedPath)) {
      // Rename to portrait.png
      fs.renameSync(extractedPath, outputPath);
      return true;
    }

    return false;
  } catch (e) {
    console.error(
      `  Error extracting ${internalPath}:`,
      e instanceof Error ? e.message : e
    );
    return false;
  }
}

function generateIndex(
  entries: Array<{ id: string; name: string; postUrl: string }>
) {
  const content = `// Auto-generated by tools/sync-paperforge.ts
// Do not edit manually

export interface PaperForgeEntry {
  id: string;
  name: string;
  postUrl?: string;
  folder: string;
}

export const PAPERFORGE_ENTRIES: PaperForgeEntry[] = ${JSON.stringify(
    entries.map((e) => ({
      id: e.id,
      name: e.name,
      postUrl: e.postUrl || undefined,
      folder: e.id.padStart(4, "0"),
    })),
    null,
    2
  )};

export function getPaperforgeEntry(identifier: string): PaperForgeEntry | null {
  // Try by ID first
  const byId = PAPERFORGE_ENTRIES.find(e => e.id === identifier);
  if (byId) return byId;

  // Try by name (case-insensitive)
  const byName = PAPERFORGE_ENTRIES.find(
    e => e.name.toLowerCase() === identifier.toLowerCase()
  );
  if (byName) return byName;

  return null;
}
`;

  fs.writeFileSync(INDEX_PATH, content);
  console.log(`\nGenerated index at ${INDEX_PATH}`);
}

function syncPaperforge() {
  const content = fs.readFileSync(CSV_PATH, "utf-8");
  const rows = parseCSV(content);

  // Filter to only rows with all data
  const completeRows = rows.filter(
    (row) => row.id && row.name && row.postUrl && row.tokenPng
  );

  // Check for duplicate IDs
  const idCounts = new Map<string, number>();
  const duplicateIds: string[] = [];

  for (const row of completeRows) {
    const count = (idCounts.get(row.id) || 0) + 1;
    idCounts.set(row.id, count);
    if (count === 2) {
      duplicateIds.push(row.id);
    }
  }

  if (duplicateIds.length > 0) {
    console.error("\n❌ ERROR: Duplicate IDs found in complete entries:");
    for (const id of duplicateIds) {
      const entries = completeRows.filter((r) => r.id === id);
      console.error(`  ID ${id}:`);
      for (const entry of entries) {
        console.error(`    - ${entry.name} (${entry.postUrl})`);
      }
    }
    process.exit(1);
  }

  console.log(`Found ${completeRows.length} complete entries to sync`);

  let successCount = 0;
  let errorCount = 0;

  const indexEntries: Array<{ id: string; name: string; postUrl: string }> = [];

  for (const row of completeRows) {
    const folderId = row.id.padStart(4, "0");
    const outputPath = path.join(OUTPUT_DIR, folderId, "portrait.png");

    console.log(`\nProcessing #${row.id}: ${row.name}`);

    // Parse tokenPng path: "VTT05_GoblinBoss_Free.zip/VTT05_GoblinBoss_Free/Portrait/GoblinBossF.png"
    const [zipFilename, ...pathParts] = row.tokenPng.split("/");
    const internalPath = pathParts.join("/");
    const zipPath = path.join(PAPERFORGE_DIR, zipFilename);

    if (!fs.existsSync(zipPath)) {
      console.log(`  ✗ Zip file not found: ${zipFilename}`);
      errorCount++;
      continue;
    }

    // Extract the image
    const success = extractTokenImage(zipPath, internalPath, outputPath);
    if (success) {
      console.log(`  ✓ Extracted to ${outputPath}`);
      successCount++;
      indexEntries.push({ id: row.id, name: row.name, postUrl: row.postUrl });
    } else {
      console.log(`  ✗ Failed to extract`);
      errorCount++;
    }
  }

  // Generate index
  if (indexEntries.length > 0) {
    generateIndex(indexEntries);
  }

  console.log(`\n=== Summary ===`);
  console.log(`Processed: ${successCount} extracted, ${errorCount} errors`);
  console.log(`Total entries in index: ${indexEntries.length}`);
}

syncPaperforge();
