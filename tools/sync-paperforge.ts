#!/usr/bin/env ts-node

import { execSync } from "node:child_process";
import * as fs from "node:fs";
import * as path from "node:path";
import AdmZip from "adm-zip";

const CSV_PATH = "data/paperforge.csv";
const PAPERFORGE_DIR = "data/paperforge";
const OUTPUT_DIR = "public/paperforge";
const INDEX_PATH = "lib/paperforge-catalog.ts";

interface CSVRow {
  id: string;
  name: string;
  postUrl: string;
  tokenDownloadUrl: string;
  tokenPng: string;
}

function escapeShellArg(arg: string): string {
  return `'${arg.replace(/'/g, "'\\''")}'`;
}

function parseCSV(content: string): CSVRow[] {
  const lines = content.split("\n");

  return lines
    .slice(1)
    .map((line) => {
      if (!line.trim()) return null;
      const [id, name, postUrl, tokenDownloadUrl, tokenPng] = line
        .split(",")
        .map((s) => s.trim());
      return { id, name, postUrl, tokenDownloadUrl, tokenPng };
    })
    .filter(Boolean) as CSVRow[];
}

function downloadZipFile(url: string, destinationDir: string): boolean {
  try {
    if (!fs.existsSync(destinationDir)) {
      fs.mkdirSync(destinationDir, { recursive: true });
    }

    execSync(`curl -OJL ${escapeShellArg(url)}`, {
      cwd: destinationDir,
      stdio: "pipe",
    });

    return true;
  } catch (e) {
    console.error(
      `  Error downloading ${url}:`,
      e instanceof Error ? e.message : e
    );
    return false;
  }
}

function extractTokenImage(
  zipPath: string,
  internalPath: string,
  outputPath: string
): boolean {
  try {
    // Create output directory
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Read the zip file
    const zip = new AdmZip(zipPath);
    const entry = zip.getEntry(internalPath);

    if (!entry) {
      console.error(`  Entry not found in zip: ${internalPath}`);
      console.error(`  Available entries:`);
      for (const e of zip.getEntries()) {
        if (!e.isDirectory) {
          console.error(`    ${e.entryName}`);
        }
      }
      return false;
    }

    // Extract the file directly to the output path
    zip.extractEntryTo(entry, outputDir, false, true);

    // Rename to portrait.png
    const extractedFilename = path.basename(internalPath);
    const extractedPath = path.join(outputDir, extractedFilename);

    if (fs.existsSync(extractedPath)) {
      fs.renameSync(extractedPath, outputPath);
      return true;
    }

    return false;
  } catch (e) {
    console.error(
      `  Error extracting ${internalPath}:`,
      e instanceof Error ? e.message : e
    );
    return false;
  }
}

function generateIndex(
  entries: Array<{ id: string; name: string; postUrl: string }>
) {
  const content = `// Auto-generated by tools/sync-paperforge.ts
// Do not edit manually

export interface PaperForgeEntry {
  id: string;
  name: string;
  postUrl?: string;
  folder: string;
}

export const PAPERFORGE_ENTRIES: PaperForgeEntry[] = ${JSON.stringify(
    entries.map((e) => ({
      id: e.id,
      name: e.name,
      postUrl: e.postUrl || undefined,
      folder: e.id.padStart(4, "0"),
    })),
    null,
    2
  )};

export function getPaperforgeEntry(identifier: string): PaperForgeEntry | null {
  // Try by ID first
  const byId = PAPERFORGE_ENTRIES.find(e => e.id === identifier);
  if (byId) return byId;

  // Try by name (case-insensitive)
  const byName = PAPERFORGE_ENTRIES.find(
    e => e.name.toLowerCase() === identifier.toLowerCase()
  );
  if (byName) return byName;

  return null;
}
`;

  fs.writeFileSync(INDEX_PATH, content);
  console.log(`\nGenerated index at ${INDEX_PATH}`);
}

function syncPaperforge() {
  const content = fs.readFileSync(CSV_PATH, "utf-8");
  const rows = parseCSV(content);

  // Filter to only rows with all data
  const completeRows = rows.filter(
    (row) => row.id && row.name && row.postUrl && row.tokenPng
  );

  // Check for duplicate IDs
  const idCounts = new Map<string, number>();
  const duplicateIds: string[] = [];

  for (const row of completeRows) {
    const count = (idCounts.get(row.id) || 0) + 1;
    idCounts.set(row.id, count);
    if (count === 2) {
      duplicateIds.push(row.id);
    }
  }

  if (duplicateIds.length > 0) {
    console.error("\n❌ ERROR: Duplicate IDs found in complete entries:");
    for (const id of duplicateIds) {
      const entries = completeRows.filter((r) => r.id === id);
      console.error(`  ID ${id}:`);
      for (const entry of entries) {
        console.error(`    - ${entry.name} (${entry.postUrl})`);
      }
    }
    process.exit(1);
  }

  console.log(`Found ${completeRows.length} complete entries to sync`);

  let successCount = 0;
  let errorCount = 0;

  const indexEntries: Array<{ id: string; name: string; postUrl: string }> = [];
  const failures: Array<{ id: string; name: string; reason: string }> = [];

  for (const row of completeRows) {
    const folderId = row.id.padStart(4, "0");
    const outputPath = path.join(OUTPUT_DIR, folderId, "portrait.png");

    console.log(`\nProcessing #${row.id}: ${row.name}`);

    // Parse tokenPng path: "VTT05_GoblinBoss_Free.zip/VTT05_GoblinBoss_Free/Portrait/GoblinBossF.png"
    const [zipFilename, ...pathParts] = row.tokenPng.split("/");
    const internalPath = pathParts.join("/");
    const zipPath = path.join(PAPERFORGE_DIR, zipFilename);

    if (!fs.existsSync(zipPath)) {
      console.log(`  ! Zip file not found: ${zipFilename}`);

      if (row.tokenDownloadUrl) {
        console.log(`  Attempting to download from ${row.tokenDownloadUrl}`);
        const downloaded = downloadZipFile(
          row.tokenDownloadUrl,
          PAPERFORGE_DIR
        );

        if (!downloaded || !fs.existsSync(zipPath)) {
          console.log(`  ✗ Failed to download zip file`);
          errorCount++;
          failures.push({
            id: row.id,
            name: row.name,
            reason: "Failed to download zip file",
          });
          continue;
        }

        console.log(`  ✓ Downloaded ${zipFilename}`);
      } else {
        console.log(`  ✗ No download URL available`);
        errorCount++;
        failures.push({
          id: row.id,
          name: row.name,
          reason: "No download URL available",
        });
        continue;
      }
    }

    // Extract the image
    const success = extractTokenImage(zipPath, internalPath, outputPath);
    if (success) {
      console.log(`  ✓ Extracted to ${outputPath}`);
      successCount++;
      indexEntries.push({ id: row.id, name: row.name, postUrl: row.postUrl });
    } else {
      console.log(`  ✗ Failed to extract`);
      errorCount++;
      failures.push({
        id: row.id,
        name: row.name,
        reason: "Failed to extract image from zip",
      });
    }
  }

  // Generate index
  if (indexEntries.length > 0) {
    generateIndex(indexEntries);
  }

  console.log(`\n=== Summary ===`);
  console.log(`Processed: ${successCount} extracted, ${errorCount} errors`);
  console.log(`Total entries in index: ${indexEntries.length}`);

  if (failures.length > 0) {
    console.log(`\n=== Failures ===`);
    for (const failure of failures) {
      console.log(`  #${failure.id} ${failure.name}: ${failure.reason}`);
    }
    process.exit(1);
  }
}

syncPaperforge();
