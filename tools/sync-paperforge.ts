#!/usr/bin/env ts-node

import { execSync } from "node:child_process";
import * as fs from "node:fs";
import * as path from "node:path";
import AdmZip from "adm-zip";

const CSV_PATH = "data/paperforge.csv";
const PAPERFORGE_DIR = "data/paperforge";
const OUTPUT_DIR = "public/paperforge";
const INDEX_PATH = "lib/paperforge-catalog.ts";

interface CSVRow {
  id: string;
  name: string;
  postUrl: string;
  tokenDownloadUrl: string;
  tokenPng: string;
}

function escapeShellArg(arg: string): string {
  return `'${arg.replace(/'/g, "'\\''")}'`;
}

function parseCSV(content: string): CSVRow[] {
  const lines = content.split("\n");

  return lines
    .slice(1)
    .map((line) => {
      if (!line.trim()) return null;
      const [id, name, postUrl, tokenDownloadUrl, tokenPng] = line
        .split(",")
        .map((s) => s.trim());
      return { id, name, postUrl, tokenDownloadUrl, tokenPng };
    })
    .filter(Boolean) as CSVRow[];
}

function downloadZipFile(url: string, destinationDir: string): boolean {
  try {
    if (!fs.existsSync(destinationDir)) {
      fs.mkdirSync(destinationDir, { recursive: true });
    }

    execSync(`curl -sOJL --clobber ${escapeShellArg(url)}`, {
      cwd: destinationDir,
      stdio: "pipe",
    });

    return true;
  } catch (e) {
    console.error(
      `  Error downloading ${url}:`,
      e instanceof Error ? e.message : String(e)
    );
    return false;
  }
}

function extractTokenImage(
  zipPath: string,
  internalPath: string,
  outputPath: string
): boolean {
  try {
    // Create output directory
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Read the zip file
    const zip = new AdmZip(zipPath);
    const entry = zip.getEntry(internalPath);

    if (!entry) {
      console.error(`  Entry not found in zip: ${internalPath}`);
      console.error(`  Available entries:`);
      for (const e of zip.getEntries()) {
        if (!e.isDirectory) {
          console.error(`    ${e.entryName}`);
        }
      }
      return false;
    }

    // Extract the file directly to the output path
    zip.extractEntryTo(entry, outputDir, false, true);

    // Rename to portrait.png
    const extractedFilename = path.basename(internalPath);
    const extractedPath = path.join(outputDir, extractedFilename);

    if (fs.existsSync(extractedPath)) {
      fs.renameSync(extractedPath, outputPath);
      return true;
    }

    return false;
  } catch (e) {
    console.error(
      `  Error extracting ${internalPath}:`,
      e instanceof Error ? e.message : e
    );
    return false;
  }
}

function generateIndex(
  entries: Array<{ id: string; name: string; postUrl: string }>
) {
  const entriesString = entries
    .map((e) => {
      const folder = e.id.padStart(4, "0");
      const parts = [
        `    id: ${JSON.stringify(e.id)},`,
        `    name: ${JSON.stringify(e.name)},`,
      ];
      if (e.postUrl) {
        parts.push(`    postUrl: ${JSON.stringify(e.postUrl)},`);
      }
      parts.push(`    folder: ${JSON.stringify(folder)},`);
      return `  {\n${parts.join("\n")}\n  }`;
    })
    .join(",\n");

  const content = `// Auto-generated by tools/sync-paperforge.ts
// Do not edit manually

export interface PaperForgeEntry {
  id: string;
  name: string;
  postUrl?: string;
  folder: string;
}

export const PAPERFORGE_ENTRIES: PaperForgeEntry[] = [
${entriesString},
];

export function getPaperforgeEntry(identifier: string): PaperForgeEntry | null {
  // Try by ID first
  const byId = PAPERFORGE_ENTRIES.find((e) => e.id === identifier);
  if (byId) return byId;

  // Try by name (case-insensitive)
  const byName = PAPERFORGE_ENTRIES.find(
    (e) => e.name.toLowerCase() === identifier.toLowerCase()
  );
  if (byName) return byName;

  return null;
}
`;

  fs.writeFileSync(INDEX_PATH, content);
  console.log(`\nGenerated index at ${INDEX_PATH}`);
}

function syncPaperforge() {
  const content = fs.readFileSync(CSV_PATH, "utf-8");
  const rows = parseCSV(content);

  // Filter to rows with at least id, name, and postUrl
  const completeRows = rows.filter((row) => row.id && row.name && row.postUrl);

  // Check for duplicate IDs
  const idCounts = new Map<string, number>();
  const duplicateIds: string[] = [];

  for (const row of completeRows) {
    const count = (idCounts.get(row.id) || 0) + 1;
    idCounts.set(row.id, count);
    if (count === 2) {
      duplicateIds.push(row.id);
    }
  }

  if (duplicateIds.length > 0) {
    console.error("\n❌ ERROR: Duplicate IDs found in complete entries:");
    for (const id of duplicateIds) {
      const entries = completeRows.filter((r) => r.id === id);
      console.error(`  ID ${id}:`);
      for (const entry of entries) {
        console.error(`    - ${entry.name} (${entry.postUrl})`);
      }
    }
    process.exit(1);
  }

  console.log(`Found ${completeRows.length} complete entries to sync`);

  let successCount = 0;
  let errorCount = 0;
  let csvUpdated = false;

  const indexEntries: Array<{ id: string; name: string; postUrl: string }> = [];
  const failures: Array<{ id: string; name: string; reason: string }> = [];

  for (const row of completeRows) {
    const folderId = row.id.padStart(4, "0");
    const outputPath = path.join(OUTPUT_DIR, folderId, "portrait.png");

    // Skip if both tokenPng and downloadUrl are '-' (no download available)
    if (
      (!row.tokenPng || row.tokenPng === "-") &&
      (!row.tokenDownloadUrl || row.tokenDownloadUrl === "-")
    ) {
      console.log(`⊘ #${row.id} ${row.name}: Non-free`);
      continue;
    }

    // Check if tokenPng is missing but downloadUrl exists
    if (!row.tokenPng && row.tokenDownloadUrl) {
      const downloaded = downloadZipFile(row.tokenDownloadUrl, PAPERFORGE_DIR);

      if (downloaded) {
        // Find the downloaded zip file
        const files = fs
          .readdirSync(PAPERFORGE_DIR)
          .filter((f) => f.endsWith(".zip"));
        const latestZip = files
          .map((f) => ({
            name: f,
            time: fs.statSync(path.join(PAPERFORGE_DIR, f)).mtime,
          }))
          .sort((a, b) => b.time.getTime() - a.time.getTime())[0];

        if (latestZip) {
          const zipPath = path.join(PAPERFORGE_DIR, latestZip.name);
          const zip = new AdmZip(zipPath);

          // Update CSV with zip filename
          row.tokenPng = latestZip.name;
          csvUpdated = true;

          console.log(
            `⊘ #${row.id} ${row.name}: Downloaded ${latestZip.name}, needs tokenPng path`
          );
          console.log(`  Contents:`);
          for (const entry of zip.getEntries()) {
            if (!entry.isDirectory) {
              console.log(`    ${entry.entryName}`);
            }
          }
        }
      } else {
        console.log(
          `⊘ #${row.id} ${row.name}: Failed to download, needs tokenPng path`
        );
      }

      errorCount++;
      failures.push({
        id: row.id,
        name: row.name,
        reason:
          "No tokenPng path specified - download URL provided for inspection",
      });
      continue;
    }

    if (!row.tokenPng) {
      console.log(`⊘ #${row.id} ${row.name}: No tokenPng or download URL`);
      errorCount++;
      failures.push({
        id: row.id,
        name: row.name,
        reason: "No tokenPng path specified",
      });
      continue;
    }

    // Parse tokenPng path: "VTT05_GoblinBoss_Free.zip/VTT05_GoblinBoss_Free/Portrait/GoblinBossF.png"
    const [zipFilename, ...pathParts] = row.tokenPng.split("/");
    const internalPath = pathParts.join("/");
    const zipPath = path.join(PAPERFORGE_DIR, zipFilename);

    if (!fs.existsSync(zipPath)) {
      if (row.tokenDownloadUrl) {
        const downloaded = downloadZipFile(
          row.tokenDownloadUrl,
          PAPERFORGE_DIR
        );

        if (!downloaded || !fs.existsSync(zipPath)) {
          console.log(`✗ #${row.id} ${row.name}: Failed to download`);
          errorCount++;
          failures.push({
            id: row.id,
            name: row.name,
            reason: "Failed to download zip file",
          });
          continue;
        }
      } else {
        console.log(`✗ #${row.id} ${row.name}: No download URL`);
        errorCount++;
        failures.push({
          id: row.id,
          name: row.name,
          reason: "No download URL available",
        });
        continue;
      }
    }

    // Extract the image
    const success = extractTokenImage(zipPath, internalPath, outputPath);
    if (success) {
      console.log(`✓ #${row.id} ${row.name}`);
      successCount++;
      indexEntries.push({ id: row.id, name: row.name, postUrl: row.postUrl });
    } else {
      console.log(`✗ #${row.id} ${row.name}: Failed to extract`);
      errorCount++;
      failures.push({
        id: row.id,
        name: row.name,
        reason: "Failed to extract image from zip",
      });
    }
  }

  // Generate index
  if (indexEntries.length > 0) {
    generateIndex(indexEntries);
  }

  // Write updated CSV if needed
  if (csvUpdated) {
    const header = "id,name,postUrl,tokenDownloadUrl,tokenPng";
    const csvLines = [
      header,
      ...rows.map((row) =>
        [
          row.id,
          row.name,
          row.postUrl,
          row.tokenDownloadUrl,
          row.tokenPng,
        ].join(",")
      ),
    ];
    fs.writeFileSync(CSV_PATH, `${csvLines.join("\n")}\n`);
    console.log(`\n✓ Updated CSV with new zip filenames`);
  }

  console.log(`\n=== Summary ===`);
  console.log(`Processed: ${successCount} extracted, ${errorCount} errors`);
  console.log(`Total entries in index: ${indexEntries.length}`);

  if (failures.length > 0) {
    console.log(`\n=== Failures ===`);
    for (const failure of failures) {
      console.log(`  #${failure.id} ${failure.name}: ${failure.reason}`);
    }
    process.exit(1);
  }
}

syncPaperforge();
