// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package sqldb

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addMonsterToCollection = `-- name: AddMonsterToCollection :exec
INSERT INTO monsters_collections (monster_id, collection_id) VALUES ($1, $2)
`

func (q *Queries) AddMonsterToCollection(ctx context.Context, monsterID uuid.UUID, collectionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, addMonsterToCollection, monsterID, collectionID)
	return err
}

const cleanExpiredSessions = `-- name: CleanExpiredSessions :exec
DELETE FROM sessions WHERE expires_at <= NOW()
`

func (q *Queries) CleanExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanExpiredSessions)
	return err
}

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (
    name, visibility, user_id, description
) VALUES (
    $1, $2, $3, $4
) RETURNING id, user_id, name, public, created_at, updated_at, description, visibility
`

type CreateCollectionParams struct {
	Name        string
	Visibility  CollectionVisibility
	UserID      uuid.UUID
	Description string
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, createCollection,
		arg.Name,
		arg.Visibility,
		arg.UserID,
		arg.Description,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.Visibility,
	)
	return i, err
}

const createLegendaryMonster = `-- name: CreateLegendaryMonster :one
INSERT INTO monsters (
    user_id, name, kind, level, hp, armor, size, actions, abilities, bloodied, last_stand, saves, legendary
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, true
) RETURNING id, name, level, hp, armor, size, speed, fly, swim, actions, abilities, legendary, bloodied, last_stand, saves, created_at, updated_at, user_id, kind, visibility
`

type CreateLegendaryMonsterParams struct {
	UserID    uuid.UUID
	Name      string
	Kind      string
	Level     string
	Hp        int32
	Armor     ArmorType
	Size      SizeType
	Actions   [][]byte
	Abilities [][]byte
	Bloodied  string
	LastStand string
	Saves     []string
}

func (q *Queries) CreateLegendaryMonster(ctx context.Context, arg CreateLegendaryMonsterParams) (Monster, error) {
	row := q.db.QueryRow(ctx, createLegendaryMonster,
		arg.UserID,
		arg.Name,
		arg.Kind,
		arg.Level,
		arg.Hp,
		arg.Armor,
		arg.Size,
		arg.Actions,
		arg.Abilities,
		arg.Bloodied,
		arg.LastStand,
		arg.Saves,
	)
	var i Monster
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Level,
		&i.Hp,
		&i.Armor,
		&i.Size,
		&i.Speed,
		&i.Fly,
		&i.Swim,
		&i.Actions,
		&i.Abilities,
		&i.Legendary,
		&i.Bloodied,
		&i.LastStand,
		&i.Saves,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Kind,
		&i.Visibility,
	)
	return i, err
}

const createMonster = `-- name: CreateMonster :one
INSERT INTO monsters (
    user_id, name, level, hp, armor, size, speed, fly, swim, actions, abilities
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, name, level, hp, armor, size, speed, fly, swim, actions, abilities, legendary, bloodied, last_stand, saves, created_at, updated_at, user_id, kind, visibility
`

type CreateMonsterParams struct {
	UserID    uuid.UUID
	Name      string
	Level     string
	Hp        int32
	Armor     ArmorType
	Size      SizeType
	Speed     int32
	Fly       int32
	Swim      int32
	Actions   [][]byte
	Abilities [][]byte
}

func (q *Queries) CreateMonster(ctx context.Context, arg CreateMonsterParams) (Monster, error) {
	row := q.db.QueryRow(ctx, createMonster,
		arg.UserID,
		arg.Name,
		arg.Level,
		arg.Hp,
		arg.Armor,
		arg.Size,
		arg.Speed,
		arg.Fly,
		arg.Swim,
		arg.Actions,
		arg.Abilities,
	)
	var i Monster
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Level,
		&i.Hp,
		&i.Armor,
		&i.Size,
		&i.Speed,
		&i.Fly,
		&i.Swim,
		&i.Actions,
		&i.Abilities,
		&i.Legendary,
		&i.Bloodied,
		&i.LastStand,
		&i.Saves,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Kind,
		&i.Visibility,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (user_id, discord_id, expires_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, discord_id, expires_at
`

type CreateSessionParams struct {
	UserID    uuid.UUID
	DiscordID string
	ExpiresAt pgtype.Timestamptz
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession, arg.UserID, arg.DiscordID, arg.ExpiresAt)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DiscordID,
		&i.ExpiresAt,
	)
	return i, err
}

const deleteCollection = `-- name: DeleteCollection :one
DELETE FROM collections WHERE user_id = $1 AND id = $2 RETURNING id, user_id, name, public, created_at, updated_at, description, visibility
`

func (q *Queries) DeleteCollection(ctx context.Context, userID uuid.UUID, iD uuid.UUID) (Collection, error) {
	row := q.db.QueryRow(ctx, deleteCollection, userID, iD)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.Visibility,
	)
	return i, err
}

const deleteMonster = `-- name: DeleteMonster :one
DELETE FROM monsters WHERE user_id = $1 AND id = $2 RETURNING id, name, level, hp, armor, size, speed, fly, swim, actions, abilities, legendary, bloodied, last_stand, saves, created_at, updated_at, user_id, kind, visibility
`

func (q *Queries) DeleteMonster(ctx context.Context, userID uuid.UUID, iD uuid.UUID) (Monster, error) {
	row := q.db.QueryRow(ctx, deleteMonster, userID, iD)
	var i Monster
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Level,
		&i.Hp,
		&i.Armor,
		&i.Size,
		&i.Speed,
		&i.Fly,
		&i.Swim,
		&i.Actions,
		&i.Abilities,
		&i.Legendary,
		&i.Bloodied,
		&i.LastStand,
		&i.Saves,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Kind,
		&i.Visibility,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSession, id)
	return err
}

const getCollection = `-- name: GetCollection :one
SELECT id, user_id, name, public, created_at, updated_at, description, visibility FROM collections WHERE id = $1
`

func (q *Queries) GetCollection(ctx context.Context, id uuid.UUID) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollection, id)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.Visibility,
	)
	return i, err
}

const getMonster = `-- name: GetMonster :one
SELECT id, name, level, hp, armor, size, speed, fly, swim, actions, abilities, legendary, bloodied, last_stand, saves, created_at, updated_at, user_id, kind, visibility FROM monsters WHERE user_id = $1 AND id = $2
`

func (q *Queries) GetMonster(ctx context.Context, userID uuid.UUID, iD uuid.UUID) (Monster, error) {
	row := q.db.QueryRow(ctx, getMonster, userID, iD)
	var i Monster
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Level,
		&i.Hp,
		&i.Armor,
		&i.Size,
		&i.Speed,
		&i.Fly,
		&i.Swim,
		&i.Actions,
		&i.Abilities,
		&i.Legendary,
		&i.Bloodied,
		&i.LastStand,
		&i.Saves,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Kind,
		&i.Visibility,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, user_id, discord_id, expires_at FROM sessions WHERE id = $1
`

func (q *Queries) GetSession(ctx context.Context, id uuid.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DiscordID,
		&i.ExpiresAt,
	)
	return i, err
}

const getUserByUnexpiredSession = `-- name: GetUserByUnexpiredSession :one
SELECT users.id, users.discord_id, users.username, users.avatar, users.refresh_token FROM users
JOIN sessions ON users.id = sessions.user_id
WHERE sessions.id = $1 AND sessions.expires_at >= NOW()
`

func (q *Queries) GetUserByUnexpiredSession(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUnexpiredSession, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DiscordID,
		&i.Username,
		&i.Avatar,
		&i.RefreshToken,
	)
	return i, err
}

const listCollections = `-- name: ListCollections :many
SELECT c.id, c.user_id, c.name, c.public, c.created_at, c.updated_at, c.description, c.visibility, COUNT(mc.monster_id) as monster_count
FROM collections c
LEFT JOIN monsters_collections mc ON c.id = mc.collection_id
WHERE c.user_id = $1
GROUP BY c.id
ORDER BY c.name ASC
`

type ListCollectionsRow struct {
	ID           uuid.UUID
	UserID       uuid.UUID
	Name         string
	Public       pgtype.Bool
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	Description  string
	Visibility   CollectionVisibility
	MonsterCount int64
}

func (q *Queries) ListCollections(ctx context.Context, userID uuid.UUID) ([]ListCollectionsRow, error) {
	rows, err := q.db.Query(ctx, listCollections, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCollectionsRow
	for rows.Next() {
		var i ListCollectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Public,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Visibility,
			&i.MonsterCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFamilies = `-- name: ListFamilies :many
SELECT id, user_id, visibility, name, abilities, created_at, updated_at FROM families WHERE user_id = $1
`

func (q *Queries) ListFamilies(ctx context.Context, userID uuid.UUID) ([]Family, error) {
	rows, err := q.db.Query(ctx, listFamilies, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Family
	for rows.Next() {
		var i Family
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Visibility,
			&i.Name,
			&i.Abilities,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonsters = `-- name: ListMonsters :many
SELECT id, name, level, hp, armor, size, speed, fly, swim, actions, abilities, legendary, bloodied, last_stand, saves, created_at, updated_at, user_id, kind, visibility from monsters WHERE user_id = $1 ORDER BY name ASC
`

func (q *Queries) ListMonsters(ctx context.Context, userID uuid.UUID) ([]Monster, error) {
	rows, err := q.db.Query(ctx, listMonsters, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monster
	for rows.Next() {
		var i Monster
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Level,
			&i.Hp,
			&i.Armor,
			&i.Size,
			&i.Speed,
			&i.Fly,
			&i.Swim,
			&i.Actions,
			&i.Abilities,
			&i.Legendary,
			&i.Bloodied,
			&i.LastStand,
			&i.Saves,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Kind,
			&i.Visibility,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonstersInCollection = `-- name: ListMonstersInCollection :many
SELECT monsters.id, monsters.name, monsters.level, monsters.hp, monsters.armor, monsters.size, monsters.speed, monsters.fly, monsters.swim, monsters.actions, monsters.abilities, monsters.legendary, monsters.bloodied, monsters.last_stand, monsters.saves, monsters.created_at, monsters.updated_at, monsters.user_id, monsters.kind, monsters.visibility FROM monsters
JOIN monsters_collections ON monsters.id = monsters_collections.monster_id
WHERE collection_id = $1
`

func (q *Queries) ListMonstersInCollection(ctx context.Context, collectionID uuid.UUID) ([]Monster, error) {
	rows, err := q.db.Query(ctx, listMonstersInCollection, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monster
	for rows.Next() {
		var i Monster
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Level,
			&i.Hp,
			&i.Armor,
			&i.Size,
			&i.Speed,
			&i.Fly,
			&i.Swim,
			&i.Actions,
			&i.Abilities,
			&i.Legendary,
			&i.Bloodied,
			&i.LastStand,
			&i.Saves,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Kind,
			&i.Visibility,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicCollections = `-- name: ListPublicCollections :many
SELECT
  c.id, c.user_id, c.name, c.public, c.created_at, c.updated_at, c.description, c.visibility,
  COUNT(mc.monster_id) as monster_count,
  u.username as creator_name,
  u.avatar as creator_avatar,
  u.discord_id as creator_discord_id,
  COUNT(CASE WHEN m.legendary THEN 1 END) as legendary_count,
  COUNT(CASE WHEN NOT m.legendary THEN 1 END) as standard_count
FROM collections c
JOIN users u ON c.user_id = u.id
LEFT JOIN monsters_collections mc ON c.id = mc.collection_id
LEFT JOIN monsters m ON mc.monster_id = m.id
WHERE c.visibility = 'public'
GROUP BY c.id, u.username, u.avatar, u.discord_id
ORDER BY c.name ASC
`

type ListPublicCollectionsRow struct {
	ID               uuid.UUID
	UserID           uuid.UUID
	Name             string
	Public           pgtype.Bool
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	Description      string
	Visibility       CollectionVisibility
	MonsterCount     int64
	CreatorName      string
	CreatorAvatar    pgtype.Text
	CreatorDiscordID string
	LegendaryCount   int64
	StandardCount    int64
}

func (q *Queries) ListPublicCollections(ctx context.Context) ([]ListPublicCollectionsRow, error) {
	rows, err := q.db.Query(ctx, listPublicCollections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPublicCollectionsRow
	for rows.Next() {
		var i ListPublicCollectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Public,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Visibility,
			&i.MonsterCount,
			&i.CreatorName,
			&i.CreatorAvatar,
			&i.CreatorDiscordID,
			&i.LegendaryCount,
			&i.StandardCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicFamilies = `-- name: ListPublicFamilies :many
SELECT id, user_id, visibility, name, abilities, created_at, updated_at FROM families WHERE visibility = 'public'
`

func (q *Queries) ListPublicFamilies(ctx context.Context) ([]Family, error) {
	rows, err := q.db.Query(ctx, listPublicFamilies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Family
	for rows.Next() {
		var i Family
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Visibility,
			&i.Name,
			&i.Abilities,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicMonsters = `-- name: ListPublicMonsters :many
SELECT id, name, level, hp, armor, size, speed, fly, swim, actions, abilities, legendary, bloodied, last_stand, saves, created_at, updated_at, user_id, kind, visibility from monsters WHERE visibility = 'public' ORDER BY name ASC
`

func (q *Queries) ListPublicMonsters(ctx context.Context) ([]Monster, error) {
	rows, err := q.db.Query(ctx, listPublicMonsters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monster
	for rows.Next() {
		var i Monster
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Level,
			&i.Hp,
			&i.Armor,
			&i.Size,
			&i.Speed,
			&i.Fly,
			&i.Swim,
			&i.Actions,
			&i.Abilities,
			&i.Legendary,
			&i.Bloodied,
			&i.LastStand,
			&i.Saves,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Kind,
			&i.Visibility,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMonsterFromCollection = `-- name: RemoveMonsterFromCollection :exec
DELETE FROM monsters_collections WHERE monster_id = $1 AND collection_id = $2
`

func (q *Queries) RemoveMonsterFromCollection(ctx context.Context, monsterID uuid.UUID, collectionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeMonsterFromCollection, monsterID, collectionID)
	return err
}

const searchMonsters = `-- name: SearchMonsters :many
SELECT m.id, m.name, m.level, m.hp, m.armor, m.size, m.speed, m.fly, m.swim, m.actions, m.abilities, m.legendary, m.bloodied, m.last_stand, m.saves, m.created_at, m.updated_at, m.user_id, m.kind, m.visibility
FROM monsters m
WHERE
    similarity(lower(m.name), lower($1)) > 0.3
    OR lower(m.name) LIKE lower('%' || $1 || '%')
ORDER BY
    similarity(lower(m.name), lower($1)) DESC,
    m.name ASC
LIMIT 10
`

func (q *Queries) SearchMonsters(ctx context.Context, lower string) ([]Monster, error) {
	rows, err := q.db.Query(ctx, searchMonsters, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monster
	for rows.Next() {
		var i Monster
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Level,
			&i.Hp,
			&i.Armor,
			&i.Size,
			&i.Speed,
			&i.Fly,
			&i.Swim,
			&i.Actions,
			&i.Abilities,
			&i.Legendary,
			&i.Bloodied,
			&i.LastStand,
			&i.Saves,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Kind,
			&i.Visibility,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCollection = `-- name: UpdateCollection :one
UPDATE collections
SET name = $3,
    visibility = $4,
    description = $5
WHERE user_id = $1 AND id = $2
RETURNING id, user_id, name, public, created_at, updated_at, description, visibility
`

type UpdateCollectionParams struct {
	UserID      uuid.UUID
	ID          uuid.UUID
	Name        string
	Visibility  CollectionVisibility
	Description string
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, updateCollection,
		arg.UserID,
		arg.ID,
		arg.Name,
		arg.Visibility,
		arg.Description,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.Visibility,
	)
	return i, err
}

const updateLegendaryMonster = `-- name: UpdateLegendaryMonster :one
UPDATE monsters
SET name = $3,
    kind = $4,
    level = $5,
    hp = $6,
    armor = $7,
    size = $8,
    speed = 0,
    fly = 0,
    swim = 0,
    actions = $9,
    abilities = $10,
    bloodied = $11,
    last_stand = $12,
    saves = $13,
    visibility = $14
WHERE user_id = $1 AND id = $2 RETURNING id, name, level, hp, armor, size, speed, fly, swim, actions, abilities, legendary, bloodied, last_stand, saves, created_at, updated_at, user_id, kind, visibility
`

type UpdateLegendaryMonsterParams struct {
	UserID     uuid.UUID
	ID         uuid.UUID
	Name       string
	Kind       string
	Level      string
	Hp         int32
	Armor      ArmorType
	Size       SizeType
	Actions    [][]byte
	Abilities  [][]byte
	Bloodied   string
	LastStand  string
	Saves      []string
	Visibility MonsterVisibility
}

func (q *Queries) UpdateLegendaryMonster(ctx context.Context, arg UpdateLegendaryMonsterParams) (Monster, error) {
	row := q.db.QueryRow(ctx, updateLegendaryMonster,
		arg.UserID,
		arg.ID,
		arg.Name,
		arg.Kind,
		arg.Level,
		arg.Hp,
		arg.Armor,
		arg.Size,
		arg.Actions,
		arg.Abilities,
		arg.Bloodied,
		arg.LastStand,
		arg.Saves,
		arg.Visibility,
	)
	var i Monster
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Level,
		&i.Hp,
		&i.Armor,
		&i.Size,
		&i.Speed,
		&i.Fly,
		&i.Swim,
		&i.Actions,
		&i.Abilities,
		&i.Legendary,
		&i.Bloodied,
		&i.LastStand,
		&i.Saves,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Kind,
		&i.Visibility,
	)
	return i, err
}

const updateMonster = `-- name: UpdateMonster :one
UPDATE monsters
SET name = $3,
    kind = '',
    level = $4,
    hp = $5,
    armor = $6,
    size = $7,
    speed = $8,
    fly = $9,
    swim = $10,
    actions = $11,
    abilities = $12,
    bloodied = '',
    last_stand = '',
    saves = array[]::text[],
    visibility = $13
WHERE user_id = $1 AND id = $2 RETURNING id, name, level, hp, armor, size, speed, fly, swim, actions, abilities, legendary, bloodied, last_stand, saves, created_at, updated_at, user_id, kind, visibility
`

type UpdateMonsterParams struct {
	UserID     uuid.UUID
	ID         uuid.UUID
	Name       string
	Level      string
	Hp         int32
	Armor      ArmorType
	Size       SizeType
	Speed      int32
	Fly        int32
	Swim       int32
	Actions    [][]byte
	Abilities  [][]byte
	Visibility MonsterVisibility
}

func (q *Queries) UpdateMonster(ctx context.Context, arg UpdateMonsterParams) (Monster, error) {
	row := q.db.QueryRow(ctx, updateMonster,
		arg.UserID,
		arg.ID,
		arg.Name,
		arg.Level,
		arg.Hp,
		arg.Armor,
		arg.Size,
		arg.Speed,
		arg.Fly,
		arg.Swim,
		arg.Actions,
		arg.Abilities,
		arg.Visibility,
	)
	var i Monster
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Level,
		&i.Hp,
		&i.Armor,
		&i.Size,
		&i.Speed,
		&i.Fly,
		&i.Swim,
		&i.Actions,
		&i.Abilities,
		&i.Legendary,
		&i.Bloodied,
		&i.LastStand,
		&i.Saves,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Kind,
		&i.Visibility,
	)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (discord_id, username, avatar, refresh_token)
VALUES ($1, $2, $3, $4)
ON CONFLICT (discord_id)
DO UPDATE SET
    username = $2,
    avatar = $3,
    refresh_token = $4
RETURNING id, discord_id, username, avatar, refresh_token
`

type UpsertUserParams struct {
	DiscordID    string
	Username     string
	Avatar       pgtype.Text
	RefreshToken pgtype.Text
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.DiscordID,
		arg.Username,
		arg.Avatar,
		arg.RefreshToken,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DiscordID,
		&i.Username,
		&i.Avatar,
		&i.RefreshToken,
	)
	return i, err
}
