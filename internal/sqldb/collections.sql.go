// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: collections.sql

package sqldb

import (
	"context"

	"github.com/gofrs/uuid"
)

const addMonsterToCollection = `-- name: AddMonsterToCollection :exec
INSERT INTO monsters_collections (monster_id, collection_id) VALUES ($1, $2)
`

func (q *Queries) AddMonsterToCollection(ctx context.Context, monsterID uuid.UUID, collectionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, addMonsterToCollection, monsterID, collectionID)
	return err
}

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (
    name, visibility, user_id, description
) VALUES (
    $1, $2, $3, $4
) RETURNING id, user_id, name, public, created_at, updated_at, description, visibility
`

type CreateCollectionParams struct {
	Name        string
	Visibility  CollectionVisibility
	UserID      uuid.UUID
	Description string
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, createCollection,
		arg.Name,
		arg.Visibility,
		arg.UserID,
		arg.Description,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.Visibility,
	)
	return i, err
}

const deleteCollection = `-- name: DeleteCollection :one
DELETE FROM collections WHERE id = $1 RETURNING id, user_id, name, public, created_at, updated_at, description, visibility
`

func (q *Queries) DeleteCollection(ctx context.Context, id uuid.UUID) (Collection, error) {
	row := q.db.QueryRow(ctx, deleteCollection, id)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.Visibility,
	)
	return i, err
}

const getCollection = `-- name: GetCollection :one
SELECT c.id, c.user_id, c.name, c.public, c.created_at, c.updated_at, c.description, c.visibility,
    COUNT(CASE WHEN m.legendary THEN 1 END) as legendary_count,
    COUNT(CASE WHEN NOT m.legendary THEN 1 END) as standard_count
FROM collections c
LEFT JOIN monsters_collections mc ON c.id = mc.collection_id
LEFT JOIN monsters m ON mc.monster_id = m.id
WHERE c.id = $1
GROUP BY c.id
`

type GetCollectionRow struct {
	Collection     Collection
	LegendaryCount int64
	StandardCount  int64
}

func (q *Queries) GetCollection(ctx context.Context, id uuid.UUID) (GetCollectionRow, error) {
	row := q.db.QueryRow(ctx, getCollection, id)
	var i GetCollectionRow
	err := row.Scan(
		&i.Collection.ID,
		&i.Collection.UserID,
		&i.Collection.Name,
		&i.Collection.Public,
		&i.Collection.CreatedAt,
		&i.Collection.UpdatedAt,
		&i.Collection.Description,
		&i.Collection.Visibility,
		&i.LegendaryCount,
		&i.StandardCount,
	)
	return i, err
}

const listCollections = `-- name: ListCollections :many
SELECT c.id, c.user_id, c.name, c.public, c.created_at, c.updated_at, c.description, c.visibility,
  COUNT(CASE WHEN m.legendary THEN 1 END) as legendary_count,
  COUNT(CASE WHEN NOT m.legendary THEN 1 END) as standard_count
FROM collections c
LEFT JOIN monsters_collections mc ON c.id = mc.collection_id
LEFT JOIN monsters m ON mc.monster_id = m.id
WHERE c.user_id = $1
GROUP BY c.id
ORDER BY c.name ASC
`

type ListCollectionsRow struct {
	Collection     Collection
	LegendaryCount int64
	StandardCount  int64
}

func (q *Queries) ListCollections(ctx context.Context, userID uuid.UUID) ([]ListCollectionsRow, error) {
	rows, err := q.db.Query(ctx, listCollections, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCollectionsRow
	for rows.Next() {
		var i ListCollectionsRow
		if err := rows.Scan(
			&i.Collection.ID,
			&i.Collection.UserID,
			&i.Collection.Name,
			&i.Collection.Public,
			&i.Collection.CreatedAt,
			&i.Collection.UpdatedAt,
			&i.Collection.Description,
			&i.Collection.Visibility,
			&i.LegendaryCount,
			&i.StandardCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonstersInCollection = `-- name: ListMonstersInCollection :many
SELECT monsters.id, monsters.name, monsters.level, monsters.hp, monsters.armor, monsters.size, monsters.speed, monsters.fly, monsters.swim, monsters.actions, monsters.abilities, monsters.legendary, monsters.bloodied, monsters.last_stand, monsters.saves, monsters.created_at, monsters.updated_at, monsters.user_id, monsters.kind, monsters.visibility, monsters.family_id
FROM monsters
JOIN monsters_collections ON monsters.id = monsters_collections.monster_id
WHERE collection_id = $1
`

func (q *Queries) ListMonstersInCollection(ctx context.Context, collectionID uuid.UUID) ([]Monster, error) {
	rows, err := q.db.Query(ctx, listMonstersInCollection, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monster
	for rows.Next() {
		var i Monster
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Level,
			&i.Hp,
			&i.Armor,
			&i.Size,
			&i.Speed,
			&i.Fly,
			&i.Swim,
			&i.Actions,
			&i.Abilities,
			&i.Legendary,
			&i.Bloodied,
			&i.LastStand,
			&i.Saves,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Kind,
			&i.Visibility,
			&i.FamilyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicCollections = `-- name: ListPublicCollections :many
SELECT c.id, c.user_id, c.name, c.public, c.created_at, c.updated_at, c.description, c.visibility,
  COUNT(CASE WHEN m.legendary THEN 1 END) as legendary_count,
  COUNT(CASE WHEN NOT m.legendary THEN 1 END) as standard_count
FROM collections c
LEFT JOIN monsters_collections mc ON c.id = mc.collection_id
LEFT JOIN monsters m ON mc.monster_id = m.id
WHERE c.visibility = 'public'
GROUP BY c.id
ORDER BY c.name ASC
`

type ListPublicCollectionsRow struct {
	Collection     Collection
	LegendaryCount int64
	StandardCount  int64
}

func (q *Queries) ListPublicCollections(ctx context.Context) ([]ListPublicCollectionsRow, error) {
	rows, err := q.db.Query(ctx, listPublicCollections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPublicCollectionsRow
	for rows.Next() {
		var i ListPublicCollectionsRow
		if err := rows.Scan(
			&i.Collection.ID,
			&i.Collection.UserID,
			&i.Collection.Name,
			&i.Collection.Public,
			&i.Collection.CreatedAt,
			&i.Collection.UpdatedAt,
			&i.Collection.Description,
			&i.Collection.Visibility,
			&i.LegendaryCount,
			&i.StandardCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMonsterFromCollection = `-- name: RemoveMonsterFromCollection :exec
DELETE FROM monsters_collections WHERE monster_id = $1 AND collection_id = $2
`

func (q *Queries) RemoveMonsterFromCollection(ctx context.Context, monsterID uuid.UUID, collectionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeMonsterFromCollection, monsterID, collectionID)
	return err
}

const updateCollection = `-- name: UpdateCollection :one
UPDATE collections
SET name = $3,
    visibility = $4,
    description = $5
WHERE user_id = $1 AND id = $2
RETURNING id, user_id, name, public, created_at, updated_at, description, visibility
`

type UpdateCollectionParams struct {
	UserID      uuid.UUID
	ID          uuid.UUID
	Name        string
	Visibility  CollectionVisibility
	Description string
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, updateCollection,
		arg.UserID,
		arg.ID,
		arg.Name,
		arg.Visibility,
		arg.Description,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.Visibility,
	)
	return i, err
}
